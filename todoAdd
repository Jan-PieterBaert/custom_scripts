#!/bin/env python3

import sys
import argparse
import re
import time
import subprocess
from operator import attrgetter

defaultFile = "/fast_files/git_repos/personal_stuff/todo.md"

parser = argparse.ArgumentParser()
parser.add_argument("--test", help="Run the doctests to see if everything is still fine", action="store_true")
parser.add_argument("--date", help="The date of the todo")
parser.add_argument("--priority", help="The priority of the todo (0-4)", type=int)
parser.add_argument("--description", help="The description of the todo")
parser.add_argument("--category", help="The category of the todo")
parser.add_argument("--remove-first", help="Remove the first item making sure you want to remove it",
                    action="store_true")
parser.add_argument("--list", help="List all todos", action="store_true")
args = parser.parse_args()


def query_yes_no(question, default="no"):
    """Ask a yes/no question via input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: {}'".format())

    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")


class TodoItemExecption(Exception):
    def __init__(self):
        pass


class TodoItem:
    """
    >>> TodoItem("| Din 26/2/2019 | 4 | Verjaardag | Varia |")
    Todoitem: "| Tue 26/02/2019 | 4 | Verjaardag | Varia |"
    >>> TodoItem("| Din 26/2/2019 | 4 | Verjaardag |")
    Traceback (most recent call last):
        ...
    AssertionError
    """

    def __init__(self, line):
        elements = list(filter(None, [element.strip() for element in line.strip().split("|")]))
        assert len(elements) == 4
        try:
            self._date = time.strptime(elements[0].split(" ")[-1], "%d/%m/%Y")
        except:
            raise AssertionError
        self.prio = elements[1]
        assert 0 <= int(self.prio) <= 4
        self.description = elements[2]
        self.category = elements[3]

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __hash__(self):
        return hash(str(self))

    @property
    def datestr(self):
        return time.strftime("%a %d/%m/%Y", self._date)

    @property
    def date(self):
        return self._date

    def __repr__(self):
        return "Todoitem: \"{}\"".format(str(self))

    def __str__(self):
        return "| {} | {} | {} | {} |".format(self.datestr, self.prio, self.description, self.category)


def findStartEnd(fileName):
    """
    >>> findStartEnd("todoTestFile1")
    (4, 42)
    >>> findStartEnd("todoTestFile2")
    Traceback (most recent call last):
        ...
    AssertionError
    """
    startIndex = 0
    endIndex = 0
    with open(fileName) as file:
        i = 0
        for line in file:
            i += 1
            if re.match("# CalendarStart", line.rstrip("\n")):
                startIndex = i
            if re.match("# CalendarEnd", line.rstrip("\n")):
                endIndex = i

    assert startIndex < endIndex

    return startIndex + 2, endIndex - 1


def getSortedTodos(fileName, newTodos=[]):
    """
    >>> getSortedTodos("todoTestFile1")
    [Todoitem: "| Sat 02/02/2019 | 0 | Belangrijk ding | Groep1 |", Todoitem: "| Mon 11/02/2019 | 1 | Start studeren | Groep3 |", Todoitem: "| Mon 11/02/2019 | 2 | Vergadering fso | Groeprft32yguqw |", Todoitem: "| Mon 11/02/2019 | 3 | Start studeren | Groep10 |", Todoitem: "| Mon 11/02/2019 | 4 | Start studeren | Groep520 |"]
    >>> getSortedTodos("todoTestFile2")
    Traceback (most recent call last):
        ...
    AssertionError
    """
    startIndex, endIndex = findStartEnd(fileName)
    lineFound = False
    i = 0
    with open(fileName) as file:
        for line in file:
            i += 1
            if i < startIndex + 1 or i > endIndex:
                continue

            if lineFound and len(line.strip()):
                newTodos.append(TodoItem(line))

            if re.sub("[|: -]*", "", line):
                lineFound = True
    return sorted(set(newTodos), key=attrgetter("date", "prio"))


def addTodo(fileName, date="", prio=4, description="", category=""):
    """
    >>> addTodo("todoTestFile1", "1/2/2019", 0, "testtest", "Varia")
    [Todoitem: "| Fri 01/02/2019 | 0 | testtest | Varia |", Todoitem: "| Sat 02/02/2019 | 0 | Belangrijk ding | Groep1 |", Todoitem: "| Mon 11/02/2019 | 1 | Start studeren | Groep3 |", Todoitem: "| Mon 11/02/2019 | 2 | Vergadering fso | Groeprft32yguqw |", Todoitem: "| Mon 11/02/2019 | 3 | Start studeren | Groep10 |", Todoitem: "| Mon 11/02/2019 | 4 | Start studeren | Groep520 |"]
    """
    newTodo = TodoItem("{}|{}|{}|{}".format(date, str(prio), description, category))
    return getSortedTodos(fileName, [newTodo])


def removeFirstTodo(fileName):
    """
    >>> removeFirstTodo("todoTestFile1")
    [Todoitem: "| Mon 11/02/2019 | 1 | Start studeren | Groep3 |", Todoitem: "| Mon 11/02/2019 | 2 | Vergadering fso | Groeprft32yguqw |", Todoitem: "| Mon 11/02/2019 | 3 | Start studeren | Groep10 |", Todoitem: "| Mon 11/02/2019 | 4 | Start studeren | Groep520 |"]
    """
    todos = getSortedTodos(fileName)
    return todos[0], todos[1:]


def editFileAdd(fileName):
    middle = [str(a) + "\n" for a in addTodo(fileName, args.date, args.priority, args.description, args.category)]
    front = []
    back = ["\n"]
    i = 0
    startIndex, endIndex = findStartEnd(fileName)
    with open(fileName) as file:
        for line in file:
            if i <= startIndex:
                front.append(line)
            if i >= endIndex:
                back.append(line)
            i += 1
    return front + middle + back


def editFileRemove(fileName):
    removedTodo, todos = removeFirstTodo(fileName)
    removeIt = query_yes_no("Sure you want to remove {}".format(removedTodo))
    if not removeIt:
        todos = [removedTodo] + todos
    middle = [str(a) + "\n" for a in todos]
    front = []
    back = ["\n"]
    i = 0
    startIndex, endIndex = findStartEnd(fileName)
    with open(fileName) as file:
        for line in file:
            if i <= startIndex:
                front.append(line)
            if i >= endIndex:
                back.append(line)
            i += 1
    return front + middle + back


if args.test:
    import doctest

    doctest.testmod()
    exit()
elif args.remove_first:
    with open("/tmp/todoAdd", 'w+') as file:
        file.writelines(editFileRemove(defaultFile))
    subprocess.call("mv /tmp/todoAdd {}".format(defaultFile), shell=True)
elif args.list:
    print("Todos: datum|prio|uitleg|categorie")
    print("\n".join([str(s) for s in getSortedTodos(defaultFile)]))
else:
    with open("/tmp/todoAdd", 'w+') as file:
        file.writelines(editFileAdd(defaultFile))
    subprocess.call("mv /tmp/todoAdd {}".format(defaultFile), shell=True)
